<!--
```agda
{-# OPTIONS --without-K --safe #-}

module sorting where 

open import prelude
open import isomorphisms
open import strict-total-order
```
-->

# A Specification of Sorting Algormithms

With the previous material in place, we can now specify what we mean
by a sorting algorithm.  As a first attempt, we might try just
a pair of a function and a proof that its output is sorted, as follows:

<!--
```agda
module _ where
  private
```
-->
```agda
    SortingAlgorithm : (X : Type) (Ï„ : StrictTotalOrder X) â†’ Type
    SortingAlgorithm X Ï„ = Î£ sort ê‰ (List X â†’ List X) ,
                             ((xs : List X) â†’ Sorted Ï„ (sort xs))
```
But this specification suffers from a serious problem: it allows us
to provide the constant function as an example sorting algorithm:
```agda
    TrivialSorting : (X : Type) (Ï„ : StrictTotalOrder X) â†’ SortingAlgorithm X Ï„
    TrivialSorting X Ï„ = (Î» _ â†’ []) , Î» _ â†’ nil-sorted 
```
We clearly need some way to exclude this kind of trivial example.

## Permutations

What is missing from our previous specification is the statement that
**the sorted list should have the same elements as the input list**.
Our next task, therefore is to make this idea precise.  Let us begin
by defining the *positions* of a list by recursion:

```agda
Pos : {X : Type} â†’ List X â†’ Type
Pos [] = ğŸ˜
Pos (_ :: xs) = ğŸ™ âˆ” Pos xs
```
The intuition is that the positions are the valid indices of the list,
but rendered as a type.  Each time the list is extended by one, there
is a new position, namely the one in which the new element sits.

Once we have the notion of position, we can write a function which
extracts the *inhabitant* of that position:
```agda
Inhab : {X : Type} (l : List X) â†’ Pos l â†’ X
Inhab (x :: _) (inl â‹†) = x
Inhab (_ :: l) (inr p) = Inhab l p
```

To say what this function does in words: when the position is the new
one generated by appending an element, we simply return that element.
Otherwise we just recurse.

<!--
```agda
open _â‰…_
```
-->

Now we can say what it means for one list to be a *permutation* of
another.  First, we require an isomorphism between the sets of
positions.  This ensures, for example, that the lists have the same
length.  (**Exercise:** Prove this!).  Then we ask that for every
position, the inhabitant of the first list at that position is equal
to the inhabitant of the second list at the position specified by the
given isomorphism.

```agda
-- module _ where
--   open import List-functions
--   private
  
--     --xs-â‰…-pos-ys-imp-len-xs-â‰¡-len-ys
--     pos-imp-len : {X : Type} {xs ys : List X} â†’ (Pos xs â‰… Pos ys) â†’ (length xs â‰¡ length ys)
--     pos-imp-len {X} {[]} {[]} (Isomorphism f (Inverse g fg gf)) = refl zero
--     pos-imp-len {X} {[]} {x :: ys} (Isomorphism f (Inverse g fg gf)) = ğŸ˜-elim (g (inl â‹†))
--     pos-imp-len {X} {x :: xs} {[]} (Isomorphism f (Inverse g fg gf)) = ğŸ˜-elim (f (inl â‹†))
--     pos-imp-len {X} {x :: xs} {y :: ys} (Isomorphism f (Inverse g fg gf)) = ap suc {!!}
```

```agda
record _IsPermutationOf_ {X : Type} (xs ys : List X) : Type where
  field
    pos-iso : Pos xs â‰… Pos ys
    inhab-eq : (p : Pos xs) â†’ Inhab xs p â‰¡ Inhab ys (bijection pos-iso p) 

```

##  Sorting Algorithms

Now that we have the notion of permutation, we can improve our specification
of sorting algorithms.  We will formulate the spec as a record:

```agda
record SortingAlgorithm {X : Type} (Ï„ : StrictTotalOrder X) : Type where
  field
    sort : List X â†’ List X
    sort-is-sorted : (xs : List X) â†’ Sorted Ï„ (sort xs)
    sort-is-permutation : (xs : List X) â†’ (sort xs) IsPermutationOf xs

```




